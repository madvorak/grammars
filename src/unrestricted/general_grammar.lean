import unrestricted.grammar


section general_grammar_definitions

/-- Transformation rule for a general grammar. -/
structure ggrule (τ : Type) (ν : Type) :=
(input_string : list (symbol τ ν))
(marked_nt : ν)
(contains_nt : symbol.nonterminal marked_nt ∈ input_string)
(output_string : list (symbol τ ν))

/-- General grammar that generates words over the alphabet `termi` (a type of terminals). -/
structure ggrammar (termi : Type) :=
(nt : Type)                      -- type of nonterminals
(initial : nt)                   -- initial symbol
(rules : list (ggrule termi nt)) -- rewriting rules


variables {T : Type}

def GG_transforms (g : ggrammar T) (w₁ w₂ : list (symbol T g.nt)) : Prop :=
∃ r : ggrule T g.nt,
  r ∈ g.rules ∧
  ∃ u v : list (symbol T g.nt), and
    (w₁ = u ++ r.input_string ++ v)
    (w₂ = u ++ r.output_string ++ v)

def GG_derives (g : ggrammar T) : list (symbol T g.nt) → list (symbol T g.nt) → Prop :=
relation.refl_trans_gen (GG_transforms g)

def GG_generates (g : ggrammar T) (w : list T) : Prop :=
GG_derives g [symbol.nonterminal g.initial] (list.map symbol.terminal w)

def GG_language (g : ggrammar T) : language T :=
set_of (GG_generates g)

/-- Language is generated by a general grammar. -/
def is_GGG (L : language T) : Prop :=
∃ g : ggrammar T, GG_language g = L

end general_grammar_definitions


section general_grammar_equivalent_grammar

variables {T : Type}

def ggrule_of_grule {N : Type} (r : grule T N) : ggrule T N :=
ggrule.mk
  (r.input_L ++ [symbol.nonterminal r.input_N] ++ r.input_R)
  r.input_N
  (by {
    apply list.mem_append_left,
    apply list.mem_append_right,
    apply list.mem_singleton_self,
  })
  r.output_string

def grule_of_ggrule {N : Type} (r : ggrule T N) /-[decidable_eq (symbol T N)]-/ : grule T N :=
let index := 42 -- list.index_of (symbol.nonterminal r.marked_nt) r.input_string
--let foo := list.nth_le_of_mem r.contains_nt
in grule.mk
  (list.take index r.input_string)
  r.marked_nt
  (list.drop (index + 1) r.input_string)
  r.output_string

lemma ggrule_of_grule_of_ggrule {N : Type} (r : ggrule T N) :
  ggrule_of_grule (grule_of_ggrule r) = r :=
sorry

lemma grule_of_ggrule_of_grule {N : Type} (r : grule T N) :
  grule_of_ggrule (ggrule_of_grule r) = r :=
sorry

def ggrammar_of_grammar (g : grammar T) : ggrammar T :=
ggrammar.mk g.nt g.initial (list.map ggrule_of_grule g.rules)

def grammar_of_ggrammar (g : ggrammar T) : grammar T :=
grammar.mk g.nt g.initial (list.map grule_of_ggrule g.rules)

lemma ggrammar_of_grammar_of_ggrammar (g : ggrammar T) :
  ggrammar_of_grammar (grammar_of_ggrammar g) = g :=
begin
  cases g,
  unfold ggrammar_of_grammar,
  congr,
  change list.map ggrule_of_grule (list.map grule_of_ggrule g_rules) = g_rules,
  rw list.map_map,
  apply list.map_id',
  intro r,
  apply ggrule_of_grule_of_ggrule,
end


lemma grammar_transforms_to_GG_transforms (g : grammar T) (w₁ w₂ : list (symbol T g.nt)) :
  grammar_transforms g w₁ w₂  ↔  GG_transforms (ggrammar_of_grammar g) w₁ w₂  :=
begin
  split,
  {
    rintro ⟨r, rin, u, v, bef, aft⟩,
    use ggrule_of_grule r,
    split,
    {
      change ggrule_of_grule r ∈ (list.map ggrule_of_grule g.rules),
      rw list.mem_map,
      use r,
      exact ⟨rin, rfl⟩,
    },
    use u,
    use v,
    split,
    {
      repeat {
        rw list.append_assoc at bef,
      },
      rw ←list.append_assoc [symbol.nonterminal r.input_N] _ _ at bef,
      rw ←list.append_assoc r.input_L _ _ at bef,
      rw ←list.append_assoc r.input_L _ _ at bef,
      rw ←list.append_assoc at bef,
      exact bef,
    },
    {
      exact aft,
    },
  },
  {
    rintro ⟨r, rin, u, v, bef, aft⟩,
    use grule_of_ggrule r,
    change r ∈ list.map _ _ at rin,
    rw list.mem_map at rin,
    rcases rin with ⟨r₀, rin₀, r_of_r₀⟩,
    rw ←r_of_r₀ at *,
    clear r_of_r₀,
    rw grule_of_ggrule_of_grule,
    split,
    {
      exact rin₀,
    },
    use u,
    use v,
    split,
    {
      repeat {
        rw list.append_assoc,
      },
      rw ←list.append_assoc [symbol.nonterminal r₀.input_N] _ _,
      rw ←list.append_assoc r₀.input_L _ _,
      rw ←list.append_assoc r₀.input_L _ _,
      rw ←list.append_assoc,
      exact bef,
    },
    {
      exact aft,
    },
  },
end

lemma grammar_transforms_to_GG_transforms' (g : grammar T) :
  grammar_transforms g = GG_transforms (ggrammar_of_grammar g) :=
begin
  ext w₁ w₂,
  exact grammar_transforms_to_GG_transforms g w₁ w₂,
end

lemma grammar_derives_to_GG_derives' (g : grammar T) :
  grammar_derives g = GG_derives (ggrammar_of_grammar g) :=
begin
  unfold grammar_derives,
  rw grammar_transforms_to_GG_transforms',
  refl,
end

lemma grammar_derives_to_GG_derives (g : grammar T) (v w : list (symbol T g.nt)) :
  grammar_derives g v w  ↔  GG_derives (ggrammar_of_grammar g) v w  :=
begin
  rw grammar_derives_to_GG_derives' g,
end

lemma grammar_generates_to_GG_generates' (g : grammar T) :
  grammar_generates g = GG_generates (ggrammar_of_grammar g) :=
begin
  ext w,
  unfold grammar_generates,
  unfold GG_generates,
  rw grammar_derives_to_GG_derives',
  refl,
end

lemma grammar_generates_to_GG_generates (g : grammar T) (w : list T) :
  grammar_generates g w  ↔  GG_generates (ggrammar_of_grammar g) w  :=
begin
  rw grammar_generates_to_GG_generates',
end

lemma grammar_language_to_GG_language (g : grammar T) :
  grammar_language g = GG_language (ggrammar_of_grammar g) :=
begin
  unfold grammar_language,
  unfold GG_language,
  rw grammar_generates_to_GG_generates',
end

lemma is_RE_iff_is_RE (L : language T) :
  is_RE L  ↔  is_GGG L  :=
begin
  unfold is_RE,
  unfold is_GGG,
  split,
  {
    rintro ⟨g, gL⟩,
    use ggrammar_of_grammar g,
    rw ←grammar_language_to_GG_language,
    exact gL,
  },
  {
    rintro ⟨g, gL⟩,
    use grammar_of_ggrammar g,
    rw grammar_language_to_GG_language,
    rw ggrammar_of_grammar_of_ggrammar,
    exact gL,
  },
end

lemma is_RE_iff_is_RE' :
  is_RE = @is_GGG T :=
begin
  ext L,
  exact is_RE_iff_is_RE L,
end

end general_grammar_equivalent_grammar
